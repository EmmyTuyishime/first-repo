<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>IPC::Open3 - open a process for reading, writing, and error handling using open3()</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="_podblock_" style="background-color: #cccccc; color: #000" valign="middle">
<big><strong><span class="_podblock_">&nbsp;IPC::Open3 - open a process for reading, writing, and error handling using open3()</span></strong></big>
</td></tr>
</table>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#See-Also">See Also</a></li>
  <li><a href="#WARNING">WARNING</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>IPC::Open3 - open a process for reading, writing, and error handling using open3()</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    use Symbol &#39;gensym&#39;; # vivify a separate handle for STDERR
    my $pid = open3(my $chld_in, my $chld_out, my $chld_err = gensym,
                    &#39;some&#39;, &#39;cmd&#39;, &#39;and&#39;, &#39;args&#39;);
    # or pass the command through the shell
    my $pid = open3(my $chld_in, my $chld_out, my $chld_err = gensym,
                    &#39;some cmd and args&#39;);

    # read from parent STDIN
    # send STDOUT and STDERR to already open handle
    open my $outfile, &#39;&gt;&gt;&#39;, &#39;output.txt&#39; or die &quot;open failed: $!&quot;;
    my $pid = open3(&#39;&lt;&amp;STDIN&#39;, $outfile, undef,
                    &#39;some&#39;, &#39;cmd&#39;, &#39;and&#39;, &#39;args&#39;);

    # write to parent STDOUT and STDERR
    my $pid = open3(my $chld_in, &#39;&gt;&amp;STDOUT&#39;, &#39;&gt;&amp;STDERR&#39;,
                    &#39;some&#39;, &#39;cmd&#39;, &#39;and&#39;, &#39;args&#39;);

    # reap zombie and retrieve exit status
    waitpid( $pid, 0 );
    my $child_exit_status = $? &gt;&gt; 8;</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Extremely similar to open2(), open3() spawns the given command and connects $chld_out for reading from the child, $chld_in for writing to the child, and $chld_err for errors. If $chld_err is false, or the same file descriptor as $chld_out, then STDOUT and STDERR of the child are on the same filehandle. This means that an autovivified lexical cannot be used for the STDERR filehandle, but gensym from <a href="file:/c|/perl/html/lib/Symbol.html">Symbol</a> can be used to vivify a new glob reference, see <a href="#SYNOPSIS">&quot;SYNOPSIS&quot;</a>. The $chld_in will have autoflush turned on.</p>

<p>If $chld_in begins with <code>&lt;&amp;</code>, then $chld_in will be closed in the parent, and the child will read from it directly. If $chld_out or $chld_err begins with <code>&gt;&amp;</code>, then the child will send output directly to that filehandle. In both cases, there will be a <a href="http://man.he.net/man2/dup">dup(2)</a> instead of a <a href="http://man.he.net/man2/pipe">pipe(2)</a> made.</p>

<p>If either reader or writer is the empty string or undefined, this will be replaced by an autogenerated filehandle. If so, you must pass a valid lvalue in the parameter slot so it can be overwritten in the caller, or an exception will be raised.</p>

<p>The filehandles may also be integers, in which case they are understood as file descriptors.</p>

<p>open3() returns the process ID of the child process. It doesn&#39;t return on failure: it just raises an exception matching <code>/^open3:/</code>. However, <code>exec</code> failures in the child (such as no such file or permission denied), are just reported to $chld_err under Windows and OS/2, as it is not possible to trap them.</p>

<p>If the child process dies for any reason, the next write to $chld_in is likely to generate a SIGPIPE in the parent, which is fatal by default. So you may wish to handle this signal.</p>

<p>Note if you specify <code>-</code> as the command, in an analogous fashion to <code>open(my $fh, &quot;-|&quot;)</code> the child process will just be the forked Perl process rather than an external command. This feature isn&#39;t yet supported on Win32 platforms.</p>

<p>open3() does not wait for and reap the child process after it exits. Except for short programs where it&#39;s acceptable to let the operating system take care of this, you need to do this yourself. This is normally as simple as calling <code>waitpid $pid, 0</code> when you&#39;re done with the process. Failing to do this can result in an accumulation of defunct or &quot;zombie&quot; processes. See <a href="file:/c|/perl/html/pod/perlfunc.html#waitpid">&quot;waitpid&quot; in perlfunc</a> for more information.</p>

<p>If you try to read from the child&#39;s stdout writer and their stderr writer, you&#39;ll have problems with blocking, which means you&#39;ll want to use select() or <a href="file:/c|/perl/html/lib/IO/Select.html">IO::Select</a>, which means you&#39;d best use sysread() instead of readline() for normal stuff.</p>

<p>This is very dangerous, as you may block forever. It assumes it&#39;s going to talk to something like <a href="http://man.he.net/man1/bc">bc(1)</a>, both writing to it and reading from it. This is presumably safe because you &quot;know&quot; that commands like <a href="http://man.he.net/man1/bc">bc(1)</a> will read a line at a time and output a line at a time. Programs like <a href="http://man.he.net/man1/sort">sort(1)</a> that read their entire input stream first, however, are quite apt to cause deadlock.</p>

<p>The big problem with this approach is that if you don&#39;t have control over source code being run in the child process, you can&#39;t control what it does with pipe buffering. Thus you can&#39;t just open a pipe to <code>cat -v</code> and continually read and write a line from it.</p>

<h1 id="See-Also">See Also</h1>

<dl>

<dt id="IPC::Open2"><a href="file:/c|/perl/html/lib/IPC/Open2.html">IPC::Open2</a></dt>
<dd>

<p>Like Open3 but without STDERR capture.</p>

</dd>
<dt id="IPC::Run"><a>IPC::Run</a></dt>
<dd>

<p>This is a CPAN module that has better error handling and more facilities than Open3.</p>

</dd>
</dl>

<h1 id="WARNING">WARNING</h1>

<p>The order of arguments differs from that of open2().</p>

<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="_podblock_" style="background-color: #cccccc; color: #000" valign="middle">
<big><strong><span class="_podblock_">&nbsp;IPC::Open3 - open a process for reading, writing, and error handling using open3()</span></strong></big>
</td></tr>
</table>

</body>

</html>


